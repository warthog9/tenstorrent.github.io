

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Buda Workload Overview &mdash; TT Buda  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/tt_theme.css?v=0bbfeaf8" />

  
    <link rel="shortcut icon" href="../_static/favicon.png"/>
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >



<a href="https://tenstorrent.github.io/">
    <img src="../_static/tt_logo.svg" class="logo" alt="Logo"/>
</a>

<a href="../toc.html">
    TT Buda
</a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Introduction to PyBuda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user_guide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../advanced_user_guide.html">Advanced User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Hardware Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataformats.html">Data Formats and Math Fidelity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developer Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../toc.html">TT Buda</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../toc.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Buda Workload Overview</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/backend/op.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="buda-workload-overview">
<h1>Buda Workload Overview<a class="headerlink" href="#buda-workload-overview" title="Link to this heading"></a></h1>
<p>A Buda workload is a collection of ML modules that are placed to run on one or more computer systems that each contain one or more Tenstorrent chips. Buda makes it easy to divide workload into modules
and spread over both small and large hardware topologies.</p>
<p>A Buda module is represented as a graph of math operations (<a class="reference internal" href="../terminology.html#op"><span class="std std-ref">Ops</span></a>). Writing out a module is very similar to how it is done in other frameworks, like PyTorch or TensorFlow: operations are
listed one by one in Python or C++ code, and outputs of operations are fed as inputs into others, creating compute graph connections.</p>
<p>An op is <em>placed</em> on to a grid of one or more Tensix cores, which are going be responsible for performing the computation. It is the model writer’s responsibility to choose the size of this grid.
Typically, larger operations should be placed onto more cores than smaller ones in order to keep the computation balanced across all Tensix cores, but many other parameters come into play: placement,
routing, bandwidths, local memory availability, and so on. These will be covered in detail later on.</p>
<p>Buda compiler will automatically place and connect operations in a graph. While it will do a good job of optimizing the placement and routing of operations in many cases, there will be situations
where manual intervention is needed to get the most performance out of hardware. Visualizations, reports, and APIs are available to users to get detailed feedback on expected performance, problem
areas and bottlenecks, and tools to fix them.</p>
<p>Commonly, the full module will not fit on available hardware, unless either the model is very small, or is being placed onto a large grid of Tenstorrent chips. In that case, the Buda compiler will
split the module into <a class="reference internal" href="../terminology.html#epoch"><span class="std std-ref">epochs</span></a>. During an epoch, placement and routing between operations is static, and one or more input tensors are fed through this pipeline of operations until
outputs are produced at the end of the epoch. An epoch could run this way through either a single input or a large batch of inputs, buffering the outputs in local memory, DRAM, or on another chip.</p>
<p>Within an epoch, operations are connected using <a class="reference internal" href="../terminology.html#pipe"><span class="std std-ref">pipes</span></a> and <a class="reference internal" href="../terminology.html#buffer"><span class="std std-ref">buffers</span></a>. Each operation defines its own input and output buffers based on its needs, and then creates pipes
between source operations and its input buffers. There is an understanding that the source operations produces data in a row-major tile order, evenly split along the grid of cores it was placed on.
If this is not compatible with the consuming op, a <a class="reference internal" href="../terminology.html#tm-op"><span class="std std-ref">TM op</span></a> will need to be inserted to bring data into expected form.</p>
<p>Pipes provide for a flexible connectivity between operations, allowing for many kinds of topologies. See <a class="reference internal" href="../terminology.html#unicast"><span class="std std-ref">Unicast</span></a>, <a class="reference internal" href="../terminology.html#multicast"><span class="std std-ref">Multicast</span></a>, and <a class="reference internal" href="../terminology.html#gather"><span class="std std-ref">Gather</span></a> for more details.</p>
<section id="anatomy-of-a-buda-op">
<h2>Anatomy of a Buda op<a class="headerlink" href="#anatomy-of-a-buda-op" title="Link to this heading"></a></h2>
<p>A functional Buda op has several responsibilities: it needs to define the math operation it performs, the buffering requirements for it input operands and its output(s), connectivity between itself
and the previous operations, and provide performance modelling feedback.</p>
<p>The math operation is defined through a high-level kernel (<a class="reference internal" href="../terminology.html#hlk"><span class="std std-ref">HLK</span></a>). A typical HLK looks like simple single-threaded piece of code in which input operands are read, math performed on them, and
output written out.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">hlk_main</span><span class="p">(</span><span class="n">tt_core</span><span class="w"> </span><span class="o">*</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">hlk_args_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">args</span><span class="o">-&gt;</span><span class="n">per_core_tile_cnt</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">t</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">hlk_acquire_dst</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">DstMode</span><span class="o">::</span><span class="n">Tile</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Wait for tiles on the input</span>
<span class="w">        </span><span class="n">hlk_wait_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">hlk_wait_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Wait for space in output</span>
<span class="w">        </span><span class="n">hlk_wait_for_free_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Add and pack</span>
<span class="w">        </span><span class="n">hlk_add_tile</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in0</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">hlk_pack_tile_to_stream</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">out0</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Pop input and push to output</span>
<span class="w">        </span><span class="n">hlk_pop_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">hlk_pop_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">in1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">hlk_push_tiles</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">HlkOperand</span><span class="o">::</span><span class="n">out0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">        </span><span class="n">hlk_release_dst</span><span class="p">(</span><span class="n">core_ptr</span><span class="p">,</span><span class="w"> </span><span class="n">DstMode</span><span class="o">::</span><span class="n">Tile</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An HLK uses hlk_ API to perform low-level actions in Tensix cores. These involve waiting for <a class="reference internal" href="../terminology.html#tile"><span class="std std-ref">tiles</span></a> to arrive in input buffers, reading them into source operands, running math
primitives, and packing and pushing output data back to output operands. The API implementation is in <a class="reference internal" href="../terminology.html#llk"><span class="std std-ref">low-level kernels</span></a>, which are highly optimized pieces of code that abstract away many
of the details of hardware programming.</p>
<p>In addition to HLKs, a Buda op defines <a class="reference internal" href="../terminology.html#buffer"><span class="std std-ref">buffers</span></a> and <a class="reference internal" href="../terminology.html#pipe"><span class="std std-ref">pipes</span></a> needed to move data to and from the operation. The Buda op will create input buffers for each of its operands
based on its requirements. A <a class="reference internal" href="../terminology.html#streaming-op"><span class="std std-ref">Streaming op</span></a> might only need room for two input tiles, while a <a class="reference internal" href="../terminology.html#blocking-op"><span class="std std-ref">Blocking op</span></a> will need to store at least two blocks to be able to perform at 100%. An output
buffer should be sizes to contain at least one output <a class="reference internal" href="../terminology.html#block"><span class="std std-ref">Block</span></a> to prevent deadlocks, but the actual sizing will depend on the performance requirements.</p>
<p>Once the buffers are in places, the Buda op defines pipes to bring data in from incoming operations into its input buffers. Depending on the op requirements, it might need a set of <a class="reference internal" href="../terminology.html#unicast"><span class="std std-ref">Unicast</span></a>
pipes (for example, an elementwise operation), or a <a class="reference internal" href="../terminology.html#multicast"><span class="std std-ref">Multicast</span></a> if several of its cores will be using the same data (most common example of this is a matrix multiplication op).</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Tenstorrent.
      <span class="lastupdated">Last updated on May 09, 2025.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
        Version: latest
        <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
        
        <dl>
            <dt>Versions</dt>
            
            <dd><a href="https://tenstorrent.github.io/pybuda/versions/index.html">versions</a></dd>
            
        </dl>
        
        <br>
        </dl>
    </div>
</div>
<script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>