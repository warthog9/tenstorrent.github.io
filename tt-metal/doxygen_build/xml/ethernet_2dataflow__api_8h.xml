<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.11.0" xml:lang="en-US">
  <compounddef id="ethernet_2dataflow__api_8h" kind="file" language="C++">
    <compoundname>dataflow_api.h</compoundname>
    <includes local="yes">risc_common.h</includes>
    <includes local="yes">dev_msgs.h</includes>
    <includes local="yes">eth_l1_address_map.h</includes>
    <includes local="yes">tt_eth_api.h</includes>
    <includes local="yes">erisc.h</includes>
    <includes local="yes">tools/profiler/kernel_profiler.hpp</includes>
    <includes local="yes">noc_nonblocking_api.h</includes>
    <includes refid="dataflow__api_8h" local="yes">../dataflow_api.h</includes>
    <includes local="yes">tunneling.h</includes>
    <incdepgraph>
      <node id="9">
        <label>../dataflow_api.h</label>
        <link refid="dataflow__api_8h"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>tt_metal/hw/inc/ethernet/dataflow_api.h</label>
        <link refid="ethernet_2dataflow__api_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>circular_buffer.h</label>
      </node>
      <node id="18">
        <label>debug/assert.h</label>
      </node>
      <node id="12">
        <label>debug/sanitize_noc.h</label>
      </node>
      <node id="13">
        <label>debug/status.h</label>
      </node>
      <node id="3">
        <label>dev_msgs.h</label>
      </node>
      <node id="6">
        <label>erisc.h</label>
      </node>
      <node id="4">
        <label>eth_l1_address_map.h</label>
      </node>
      <node id="14">
        <label>hostdevcommon/common_runtime_address_map.h</label>
      </node>
      <node id="15">
        <label>hostdevcommon/common_values.hpp</label>
      </node>
      <node id="8">
        <label>noc_nonblocking_api.h</label>
      </node>
      <node id="16">
        <label>risc_attribs.h</label>
      </node>
      <node id="2">
        <label>risc_common.h</label>
      </node>
      <node id="10">
        <label>stdint.h</label>
      </node>
      <node id="17">
        <label>third_party/umd/device/tt_silicon_driver_common.hpp</label>
      </node>
      <node id="7">
        <label>tools/profiler/kernel_profiler.hpp</label>
      </node>
      <node id="5">
        <label>tt_eth_api.h</label>
      </node>
      <node id="19">
        <label>tunneling.h</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a9d454f81bcb8875f528a900fa9326bc6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool eth_txq_is_busy</definition>
        <argsstring>()</argsstring>
        <name>eth_txq_is_busy</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Indicates if the ethernet transaction queue is busy ingesting a command at this moment,</para>
<para>Return value: bool: true if the queue is ingesting a command and cannot accept a new one at this specific moment </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="26" column="7" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="26" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a6329560698216d90086e2aa33b9ca1b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_noc_semaphore_wait</definition>
        <argsstring>(volatile uint32_t *sem_addr, uint32_t val)</argsstring>
        <name>eth_noc_semaphore_wait</name>
        <param>
          <type>volatile uint32_t *</type>
          <declname>sem_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <emphasis>noc_semaphore_set</emphasis>.</para>
<para>Return value: None</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>sem_addr   </para>
</entry><entry thead="no"><para>Semaphore address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>val   </para>
</entry><entry thead="no"><para>The target value of the semaphore   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>Any uint32_t value   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="45" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="45" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a898d637ad953ac08a4e5d2fe8b077049" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_noc_semaphore_wait_min</definition>
        <argsstring>(volatile uint32_t *sem_addr, uint32_t val)</argsstring>
        <name>eth_noc_semaphore_wait_min</name>
        <param>
          <type>volatile uint32_t *</type>
          <declname>sem_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see <emphasis>noc_semaphore_set</emphasis>.</para>
<para>Return value: None</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>sem_addr   </para>
</entry><entry thead="no"><para>Semaphore address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>val   </para>
</entry><entry thead="no"><para>The target value of the semaphore   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>Any uint32_t value   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="65" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="65" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1ae23f90aed9456576bb85b298a1ce877b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_noc_async_read_barrier</definition>
        <argsstring>()</argsstring>
        <name>eth_noc_async_read_barrier</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This blocking call waits for all the outstanding enqueued <emphasis>noc_async_read</emphasis> calls issued on the current Tensix core to complete. After returning from this call the <emphasis>noc_async_read</emphasis> queue will be empty for the current Tensix core.</para>
<para>Return value: None </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="79" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="79" bodyend="83"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a9d47f0940202285a7f23982692e20f59" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_noc_async_write_barrier</definition>
        <argsstring>()</argsstring>
        <name>eth_noc_async_write_barrier</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This blocking call waits for all the outstanding enqueued <emphasis>noc_async_write</emphasis> calls issued on the current Tensix core to complete. After returning from this call the <emphasis>noc_async_write</emphasis> queue will be empty for the current Tensix core.</para>
<para>Return value: None </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="94" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="94" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a5b57f8d14c6a15d3680d7284582a786c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_send_bytes</definition>
        <argsstring>(uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</argsstring>
        <name>eth_send_bytes</name>
        <param>
          <type>uint32_t</type>
          <declname>src_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>dst_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send</declname>
          <defval>16</defval>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send_word_size</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiates an asynchronous write from a source address in L1 memory on the local ethernet core to L1 of the connected remote ethernet core. Also, see <emphasis>eth_wait_for_receiver_done</emphasis> and <emphasis>eth_wait_for_bytes</emphasis>.</para>
<para>Return value: None</para>
<para><table rows="4" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>src_addr   </para>
</entry><entry thead="no"><para>Source address in local eth core L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>dst_addr   </para>
</entry><entry thead="no"><para>Destination address in remote eth core L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes   </para>
</entry><entry thead="no"><para>Size of data transfer in bytes, must be multiple of 16   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="113" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="113" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a49af0f0508c67af19ceaadd83bc51eba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_send_bytes_over_channel_payload_only</definition>
        <argsstring>(uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t channel, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</argsstring>
        <name>eth_send_bytes_over_channel_payload_only</name>
        <param>
          <type>uint32_t</type>
          <declname>src_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>dst_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send</declname>
          <defval>16</defval>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send_word_size</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiates an asynchronous write from a source address in L1 memory on the local ethernet core to L1 of the connected remote ethernet core. However, this is only the first half of the sender&apos;s part of then transaction. It does not include the sending of the write completion signature to the receiver.</para>
<para>Non-blocking</para>
<para>Return value: None</para>
<para><table rows="8" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>src_addr   </para>
</entry><entry thead="no"><para>Source address in local eth core L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>dst_addr   </para>
</entry><entry thead="no"><para>Destination address in remote eth core L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes   </para>
</entry><entry thead="no"><para>Size of data transfer in bytes, must be multiple of 16   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to use. Corresponds to   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>channels in erisc_info_t   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes_per_send   </para>
</entry><entry thead="no"><para>Number of bytes to send per packet   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>16..1MB   </para>
</entry><entry thead="no"><para>False    </para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes_per_send_word_size   </para>
</entry><entry thead="no"><para>num_bytes_per_send shifted right 4   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>1..256kB   </para>
</entry><entry thead="no"><para>False   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="148" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="148" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a781562a3dd147fc9d9430ce037a1e3da" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_send_payload_complete_signal_over_channel</definition>
        <argsstring>(uint32_t channel, uint32_t num_bytes)</argsstring>
        <name>eth_send_payload_complete_signal_over_channel</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="169" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="169" bodyend="178"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1af8a3f69ac60c29d201771f16f6498cda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_send_bytes_over_channel</definition>
        <argsstring>(uint32_t src_addr, uint32_t dst_addr, uint32_t num_bytes, uint32_t channel, uint32_t num_bytes_per_send=16, uint32_t num_bytes_per_send_word_size=1)</argsstring>
        <name>eth_send_bytes_over_channel</name>
        <param>
          <type>uint32_t</type>
          <declname>src_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>dst_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send</declname>
          <defval>16</defval>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes_per_send_word_size</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="181" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="181" bodyend="203"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1aae485db00b351232851e5e43f5cbd0f8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_write_remote_reg</definition>
        <argsstring>(uint32_t reg_addr, uint32_t value)</argsstring>
        <name>eth_write_remote_reg</name>
        <param>
          <type>uint32_t</type>
          <declname>reg_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiates an asynchronous write from the local ethernet core to a register of the connected remote ethernet core.</para>
<para>Return value: None</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>reg_addr   </para>
</entry><entry thead="no"><para>Destination address in remote eth core reg space   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0xFF000000+   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>value   </para>
</entry><entry thead="no"><para>Value to be written   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>Any value   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="218" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="218" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1ad653825a0450903f666f7f2827a55b7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_for_receiver_done</definition>
        <argsstring>()</argsstring>
        <name>eth_wait_for_receiver_done</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits for receiver to acknowledge that all data sent with eth_send_bytes since the last reset_erisc_info call is no longer being used. Also, see <emphasis>eth_receiver_done()</emphasis>.</para>
<para>Return value: None</para>
<para>| Argument | Description | Type | Valid Range | Required | |----------------<mdash/>|------------------------------------------------------<mdash/>|-------<mdash/>|----------<mdash/>|-------<mdash/>| </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="232" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="232" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a02966d06f690ca2d85533b5e6ce80809" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool eth_is_receiver_channel_send_acked</definition>
        <argsstring>(uint32_t channel)</argsstring>
        <name>eth_is_receiver_channel_send_acked</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be sender side. Indicates to caller that the receiver has received the last payload sent, and that the local sender buffer can be cleared safely</para>
<para>Non-blocking</para>
<para>Return value: bool: true if the receiver has acked</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to check. Corresponds to   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>channels in erisc_info_t   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="258" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="258" bodyend="260"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a1a37dd512972c4e57bbe6e0b198a3941" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool eth_is_receiver_channel_send_done</definition>
        <argsstring>(uint32_t channel)</argsstring>
        <name>eth_is_receiver_channel_send_done</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be sender side. Tells caller that the receiver has both received the last payload sent, and also that it has cleared it to its consumers. If true, indicates that caller (sender) send safely send more data.</para>
<para>Non-blocking</para>
<para>Return value: bool: true if the receiver has acked and forwarded the payload.</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to check. Corresponds to   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>channels in erisc_info_t   </para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry><entry thead="no"><para></para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="276" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="276" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a3ff986b2dd8f65e01aca7867bb166e96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_for_receiver_channel_done</definition>
        <argsstring>(uint32_t channel)</argsstring>
        <name>eth_wait_for_receiver_channel_done</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be sender side. This call will block until receiver sends both levels of ack</para>
<para>Blocking</para>
<para>Return value: None</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to block on   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="292" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="292" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a7be541a245801ba647612940108db385" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>write_barrier</declname>
            <defname>write_barrier</defname>
            <defval>false</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void eth_send_done</definition>
        <argsstring>()</argsstring>
        <name>eth_send_done</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits for remote receiver to acknowledge that all data sent with eth_send_bytes since the last reset_erisc_info call is no longer being used. Also, see <emphasis>eth_receiver_done()</emphasis>. This also syncs with the local receiver core using a semaphore and reads date from the receiver core</para>
<para>Return value: None</para>
<para><table rows="6" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>sender_semaphore_addr_ptr   </para>
</entry><entry thead="no"><para>Semaphore address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>receiver_semaphore_noc_addr   </para>
</entry><entry thead="no"><para>Encoding of the receiver semaphore location (x,y)+address   </para>
</entry><entry thead="no"><para>uint64_t   </para>
</entry><entry thead="no"><para>DOX-TODO(insert a reference to what constitutes valid coords)   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>receiver_data_noc_addr   </para>
</entry><entry thead="no"><para>Encoding of the receiver source location (x,y)+address   </para>
</entry><entry thead="no"><para>uint64_t   </para>
</entry><entry thead="no"><para>DOX-TODO(ref to explain valid coords)   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>dst_local_l1_addr   </para>
</entry><entry thead="no"><para>Address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>size   </para>
</entry><entry thead="no"><para>Size of data transfer in bytes   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="322" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="322" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1aa8e1a78afaa929435707fca21e2a25b4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_receiver_done</definition>
        <argsstring>()</argsstring>
        <name>eth_wait_receiver_done</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be sender side. This call will block until receiver sends both levels of ack</para>
<para>Blocking</para>
<para>Return value: None</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to block on   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="342" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="342" bodyend="346"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a1764bd208e8445bc7e47032ec99c3616" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_for_bytes</definition>
        <argsstring>(uint32_t num_bytes)</argsstring>
        <name>eth_wait_for_bytes</name>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits for num_bytes of data to be sent from the remote sender ethernet core using any number of eth_send_byte. User must ensure that num_bytes is equal to the total number of bytes sent. Example 1: eth_send_bytes(32), eth_wait_for_bytes(32). Example 2: eth_send_bytes(16), eth_send_bytes(32), eth_wait_for_bytes(48).</para>
<para>Return value: None</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes   </para>
</entry><entry thead="no"><para>Size of data transfer in bytes, must be multiple of 16   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..256kB   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="361" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="361" bodyend="365"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1af738caa9901266b6b58f0fa0b5ee779f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool eth_bytes_are_available_on_channel</definition>
        <argsstring>(uint8_t channel)</argsstring>
        <name>eth_bytes_are_available_on_channel</name>
        <param>
          <type>uint8_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be receiver side. This call will tell the receiver whether or not there is payload data to in the local buffer</para>
<para>Non-blocking</para>
<para>Return value: bool: True if payload data was sent (and not yet cleared) on the channel</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to check   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="380" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="380" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a43ad9b216541d5f830ce5297a8873b68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_for_bytes_on_channel</definition>
        <argsstring>(uint32_t num_bytes, uint8_t channel)</argsstring>
        <name>eth_wait_for_bytes_on_channel</name>
        <param>
          <type>uint32_t</type>
          <declname>num_bytes</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be receiver side. This call block until there is payload data in the local buffer associated with the channel</para>
<para>Blocking</para>
<para>Return value: None</para>
<para><table rows="3" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>num_bytes   </para>
</entry><entry thead="no"><para>Number of bytes to receive before returning to caller   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to check   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="398" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="398" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1af27bb42b34afb388a0994da0f2b73c54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_receiver_done</definition>
        <argsstring>()</argsstring>
        <name>eth_receiver_done</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initiates an asynchronous call from receiver ethernet core to tell remote sender ethernet core that data sent via eth_send_bytes is no longer being used. Also, see <emphasis>eth_wait_for_receiver_done</emphasis>. Sends over channel 0</para>
<para>Return value: None</para>
<para>| Argument | Description | Type | Valid Range | Required | |--------------------------<mdash/>|------------------------------------------------------<mdash/>|-------<mdash/>|----------<mdash/>|-------<mdash/>| </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="429" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="429" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1acd35fe4c1c09f60fc53d21a4bccbb71e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_receiver_channel_done</definition>
        <argsstring>(uint32_t channel)</argsstring>
        <name>eth_receiver_channel_done</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be receiver side. This call sends the second (and first) level ack to sender, indicating that the receiver flushed its buffer and is able to accept more data</para>
<para>Non-nlocking</para>
<para>Return value: None</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to ack   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="451" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="451" bodyend="460"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a32a1ef34f66d78ba3934c321595ff40d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_clear_sender_channel_ack</definition>
        <argsstring>(uint32_t channel)</argsstring>
        <name>eth_clear_sender_channel_ack</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be sender side. This clears the local first level ack field. Useful when resetting on sender side in preparation for next send</para>
<para>Non-blocking</para>
<para>Return value: None</para>
<para><table rows="2" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to check   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="475" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="475" bodyend="478"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a4ff4de9ce3be69c64f017b1b1facc090" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_receiver_channel_ack</definition>
        <argsstring>(uint32_t channel, uint32_t eth_transaction_ack_word_addr)</argsstring>
        <name>eth_receiver_channel_ack</name>
        <param>
          <type>uint32_t</type>
          <declname>channel</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>eth_transaction_ack_word_addr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Caller is expected to be receiver side. This sends the first level ack to sender, indicating that the last payload sent on the channel was received and that sender is free to clear its buffer</para>
<para>Non-blocking</para>
<para>Return value: None</para>
<para><table rows="5" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>channel   </para>
</entry><entry thead="no"><para>Which transaction channel to ack   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..7   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>eth_transaction_ack_word_addr   </para>
</entry><entry thead="no"><para>Address of 16B memory (also 16B aligned) segment with   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>L1 address   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>to send the eth_channel_sync_t to sender for first level   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>L1 address   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para></para>
</entry><entry thead="no"><para>ack. Must <emphasis>not</emphasis> alias erisc_info-&gt;channels[channel]   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>L1 address   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="496" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="496" bodyend="508"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a5d550f7bf6d486b386ddea8c81ad0a82" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_receiver_acknowledge</definition>
        <argsstring>(uint8_t channel=0)</argsstring>
        <name>eth_receiver_acknowledge</name>
        <param>
          <type>uint8_t</type>
          <declname>channel</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="522" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="522" bodyend="529"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1a4f1763214451d751d920191f201b2e1f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void eth_wait_receiver_acknowledge</definition>
        <argsstring>(uint8_t channel=0)</argsstring>
        <name>eth_wait_receiver_acknowledge</name>
        <param>
          <type>uint8_t</type>
          <declname>channel</declname>
          <defval>0</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="532" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="532" bodyend="536"/>
      </memberdef>
      <memberdef kind="function" id="ethernet_2dataflow__api_8h_1ab36fed1b5267fe75971b6f9e319e373b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>bool</type>
            <declname>write_barrier</declname>
            <defname>write_barrier</defname>
            <defval>false</defval>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void eth_wait_for_remote_receiver_done_and_get_local_receiver_data</definition>
        <argsstring>(volatile uint32_t *sender_semaphore_addr_ptr, uint64_t receiver_semaphore_noc_addr, uint64_t receiver_data_noc_addr, uint32_t local_eth_l1_curr_src_addr, uint32_t size)</argsstring>
        <name>eth_wait_for_remote_receiver_done_and_get_local_receiver_data</name>
        <param>
          <type>volatile uint32_t *</type>
          <declname>sender_semaphore_addr_ptr</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>receiver_semaphore_noc_addr</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>receiver_data_noc_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>local_eth_l1_curr_src_addr</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A blocking call that waits for remote receiver to acknowledge that all data sent with eth_send_bytes since the last reset_erisc_info call is no longer being used. Also, see <emphasis>eth_receiver_done()</emphasis>. This also syncs with the local receiver core using a semaphore and reads date from the receiver core</para>
<para>Return value: None</para>
<para><table rows="6" cols="5"><row>
<entry thead="yes"><para>Argument   </para>
</entry><entry thead="yes"><para>Description   </para>
</entry><entry thead="yes"><para>Type   </para>
</entry><entry thead="yes"><para>Valid Range   </para>
</entry><entry thead="yes"><para>Required    </para>
</entry></row>
<row>
<entry thead="no"><para>sender_semaphore_addr_ptr   </para>
</entry><entry thead="no"><para>Semaphore address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>receiver_semaphore_noc_addr   </para>
</entry><entry thead="no"><para>Encoding of the receiver semaphore location (x,y)+address   </para>
</entry><entry thead="no"><para>uint64_t   </para>
</entry><entry thead="no"><para>DOX-TODO(insert a reference to what constitutes valid coords)   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>receiver_data_noc_addr   </para>
</entry><entry thead="no"><para>Encoding of the receiver source location (x,y)+address   </para>
</entry><entry thead="no"><para>uint64_t   </para>
</entry><entry thead="no"><para>DOX-TODO(ref to explain valid coords)   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>dst_local_l1_addr   </para>
</entry><entry thead="no"><para>Address in local L1 memory   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True    </para>
</entry></row>
<row>
<entry thead="no"><para>size   </para>
</entry><entry thead="no"><para>Size of data transfer in bytes   </para>
</entry><entry thead="no"><para>uint32_t   </para>
</entry><entry thead="no"><para>0..1MB   </para>
</entry><entry thead="no"><para>True   </para>
</entry></row>
</table>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="tt_metal/hw/inc/ethernet/dataflow_api.h" line="556" column="6" bodyfile="tt_metal/hw/inc/ethernet/dataflow_api.h" bodystart="556" bodyend="579"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//<sp/>SPDX-FileCopyrightText:<sp/><sp/>2023<sp/>Tenstorrent<sp/>Inc.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="comment">//<sp/>SPDX-License-Identifier:<sp/>Apache-2.0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;risc_common.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;dev_msgs.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;eth_l1_address_map.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;risc_common.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;tt_eth_api.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;erisc.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;tools/profiler/kernel_profiler.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;noc_nonblocking_api.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="dataflow__api_8h" kindref="compound">../dataflow_api.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;tunneling.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal">FORCE_INLINE<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>eth_txq_is_busy()<sp/>{</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>internal_::eth_txq_is_busy(0);</highlight></codeline>
<codeline lineno="28"><highlight class="normal">}</highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_noc_semaphore_wait(</highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tt_l1_ptr<sp/>uint32_t*<sp/>sem_addr,<sp/>uint32_t<sp/>val)<sp/>{</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((*sem_addr)<sp/>!=<sp/>val)<sp/>{</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="49"><highlight class="normal">}</highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_noc_semaphore_wait_min(</highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tt_l1_ptr<sp/>uint32_t*<sp/>sem_addr,<sp/>uint32_t<sp/>val)<sp/>{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((*sem_addr)<sp/>&lt;<sp/>val)<sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="69"><highlight class="normal">}</highlight></codeline>
<codeline lineno="78"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_noc_async_read_barrier()<sp/>{</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!ncrisc_noc_reads_flushed(noc_index))<sp/>{</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="83"><highlight class="normal">}</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="94"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_noc_async_write_barrier()<sp/>{</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!ncrisc_noc_nonposted_writes_flushed(noc_index))<sp/>{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="98"><highlight class="normal">}</highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_send_bytes(</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>src_addr,</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>dst_addr,</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes,</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send<sp/>=<sp/>16,</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send_word_size<sp/>=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_sent<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num_bytes_sent<sp/>&lt;<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>((num_bytes_sent<sp/>+<sp/>src_addr)<sp/>&gt;&gt;<sp/>4),<sp/>((num_bytes_sent<sp/>+<sp/>dst_addr)<sp/>&gt;&gt;<sp/>4),<sp/>num_bytes_per_send_word_size);</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_bytes_sent<sp/>+=<sp/>num_bytes_per_send;</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[0].bytes_sent<sp/>+=<sp/>num_bytes;</highlight></codeline>
<codeline lineno="126"><highlight class="normal">}</highlight></codeline>
<codeline lineno="127"><highlight class="normal"></highlight></codeline>
<codeline lineno="147"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="148"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_send_bytes_over_channel_payload_only(</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>src_addr,</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>dst_addr,</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes,</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>channel,</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send<sp/>=<sp/>16,</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send_word_size<sp/>=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_sent<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num_bytes_sent<sp/>&lt;<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>((num_bytes_sent<sp/>+<sp/>src_addr)<sp/>&gt;&gt;<sp/>4),<sp/>((num_bytes_sent<sp/>+<sp/>dst_addr)<sp/>&gt;&gt;<sp/>4),<sp/>num_bytes_per_send_word_size);</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_bytes_sent<sp/>+=<sp/>num_bytes_per_send;</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="162"><highlight class="normal">}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/>*<sp/>Sends<sp/>the<sp/>write<sp/>completion<sp/>signal<sp/>to<sp/>the<sp/>receiver<sp/>ethernet<sp/>core,<sp/>for<sp/>transfers<sp/>where<sp/>the<sp/>payload<sp/>was<sp/>already<sp/>sent.</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/>*<sp/>The<sp/>second<sp/>half<sp/>of<sp/>a<sp/>full<sp/>ethernet<sp/>send.</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_send_payload_complete_signal_over_channel(uint32_t<sp/>channel,<sp/>uint32_t<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>=<sp/>num_bytes;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>addr<sp/>=<sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addr,</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addr,</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="178"><highlight class="normal">}</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_send_bytes_over_channel(</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>src_addr,</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>dst_addr,</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes,</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>channel,</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send<sp/>=<sp/>16,</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_per_send_word_size<sp/>=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_sent<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num_bytes_sent<sp/>&lt;<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>((num_bytes_sent<sp/>+<sp/>src_addr)<sp/>&gt;&gt;<sp/>4),<sp/>((num_bytes_sent<sp/>+<sp/>dst_addr)<sp/>&gt;&gt;<sp/>4),<sp/>num_bytes_per_send_word_size);</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_bytes_sent<sp/>+=<sp/>num_bytes_per_send;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>=<sp/>num_bytes;</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>addr<sp/>=<sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addr,</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addr,</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="203"><highlight class="normal">}</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="218"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_write_remote_reg(uint32_t<sp/>reg_addr,<sp/>uint32_t<sp/>value)<sp/>{</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_write_remote_reg(0,<sp/>reg_addr,<sp/>value);</highlight></codeline>
<codeline lineno="220"><highlight class="normal">}</highlight></codeline>
<codeline lineno="221"><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_for_receiver_done()<sp/>{</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="235"><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(erisc_info-&gt;channels[0].bytes_sent<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="242"><highlight class="normal">}</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="257"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="258"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>eth_is_receiver_channel_send_acked(uint32_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="260"><highlight class="normal">}</highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight></codeline>
<codeline lineno="275"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="276"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>eth_is_receiver_channel_send_done(uint32_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>==<sp/>0;</highlight></codeline>
<codeline lineno="278"><highlight class="normal">}</highlight></codeline>
<codeline lineno="279"><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="292"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_for_receiver_channel_done(uint32_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>max<sp/>=<sp/>100000;</highlight></codeline>
<codeline lineno="295"><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!eth_is_receiver_channel_send_done(channel))<sp/>{</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>&gt;<sp/>max)<sp/>{</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="303"><highlight class="normal">}</highlight></codeline>
<codeline lineno="304"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>write_barrier<sp/>=<sp/>false&gt;</highlight></codeline>
<codeline lineno="321"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="322"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_send_done()<sp/>{</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="328"><highlight class="normal">}</highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_receiver_done()<sp/>{</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(erisc_info-&gt;channels[0].bytes_sent<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="346"><highlight class="normal">}</highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="361"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_for_bytes(uint32_t<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(erisc_info-&gt;channels[0].bytes_sent<sp/>!=<sp/>num_bytes)<sp/>{</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="365"><highlight class="normal">}</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="380"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>eth_bytes_are_available_on_channel(uint8_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>!=<sp/>0;</highlight></codeline>
<codeline lineno="382"><highlight class="normal">}</highlight></codeline>
<codeline lineno="383"><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_for_bytes_on_channel(uint32_t<sp/>num_bytes,<sp/>uint8_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>poll_count<sp/>=<sp/>1000000;</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>num_bytes_sent<sp/>=<sp/>erisc_info-&gt;channels[channel].bytes_sent;</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(num_bytes_sent<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>received_this_iter<sp/>=<sp/>erisc_info-&gt;channels[channel].bytes_sent;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(received_this_iter<sp/>!=<sp/>num_bytes_sent)<sp/>{</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>are<sp/>currently<sp/>in<sp/>the<sp/>process<sp/>of<sp/>receiving<sp/>data<sp/>on<sp/>this<sp/>channel,<sp/>so<sp/>we<sp/>just<sp/>just<sp/>wait<sp/>a</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>bit<sp/>longer<sp/>instead<sp/>of<sp/>initiating<sp/>a<sp/>context<sp/>switch</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_bytes_sent<sp/>=<sp/>received_this_iter;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count++;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(count<sp/>&gt;<sp/>poll_count)<sp/>{</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="417"><highlight class="normal">}</highlight></codeline>
<codeline lineno="418"><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="429"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_receiver_done()<sp/>{</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[0].bytes_sent<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="436"><highlight class="normal">}</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="450"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="451"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_receiver_channel_done(uint32_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="460"><highlight class="normal">}</highlight></codeline>
<codeline lineno="461"><highlight class="normal"></highlight></codeline>
<codeline lineno="474"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="475"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_clear_sender_channel_ack(uint32_t<sp/>channel)<sp/>{</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="478"><highlight class="normal">}</highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="496"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_receiver_channel_ack(uint32_t<sp/>channel,<sp/>uint32_t<sp/>eth_transaction_ack_word_addr)<sp/>{</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>assert(channel<sp/>&lt;<sp/>4);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].receiver_ack<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERT(</highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="keyword">volatile<sp/></highlight><highlight class="normal">uint32_t*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(eth_transaction_ack_word_addr)[0]<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">reinterpret_cast&lt;</highlight><highlight class="keyword">volatile<sp/></highlight><highlight class="normal">uint32_t*</highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(eth_transaction_ack_word_addr)[1]<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Make<sp/>sure<sp/>we<sp/>don&apos;t<sp/>alias<sp/>the<sp/>erisc_info<sp/>eth_channel_sync_t</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/>ASSERT(eth_transaction_ack_word_addr<sp/>!=<sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].receiver_ack)))<sp/>&gt;&gt;<sp/>4);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eth_transaction_ack_word_addr<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].receiver_ack)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="508"><highlight class="normal">}</highlight></codeline>
<codeline lineno="509"><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight></codeline>
<codeline lineno="511"><highlight class="normal"></highlight></codeline>
<codeline lineno="512"><highlight class="normal"></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="513"><highlight class="comment"><sp/>*<sp/>Initiates<sp/>an<sp/>asynchronous<sp/>call<sp/>from<sp/>receiver<sp/>ethernet<sp/>core<sp/>to<sp/>tell<sp/>remote<sp/>sender<sp/>ethernet<sp/>core<sp/>that<sp/>data<sp/>sent</highlight></codeline>
<codeline lineno="514"><highlight class="comment"><sp/>*<sp/>via<sp/>eth_send_bytes<sp/>has<sp/>been<sp/>received.<sp/>Also,<sp/>see<sp/>\a<sp/>eth_wait_for_receiver_done</highlight></codeline>
<codeline lineno="515"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="516"><highlight class="comment"><sp/>*<sp/>Return<sp/>value:<sp/>None</highlight></codeline>
<codeline lineno="517"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="518"><highlight class="comment"><sp/>*<sp/>|<sp/>Argument<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Description<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/>Type<sp/><sp/><sp/><sp/><sp/>|<sp/>Valid<sp/>Range<sp/>|<sp/>Required<sp/>|</highlight></codeline>
<codeline lineno="519"><highlight class="comment"><sp/>*<sp/>|-------------------|---------------------------------------------------------|----------|-------------|----------|</highlight></codeline>
<codeline lineno="520"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="521"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="522"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_receiver_acknowledge(uint8_t<sp/>channel<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/>erisc_info-&gt;channels[channel].bytes_sent<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[channel].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="529"><highlight class="normal">}</highlight></codeline>
<codeline lineno="530"><highlight class="normal"></highlight></codeline>
<codeline lineno="531"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="532"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_receiver_acknowledge(uint8_t<sp/>channel<sp/>=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(erisc_info-&gt;channels[channel].bytes_sent<sp/>!=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>run_routing();</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="536"><highlight class="normal">}</highlight></codeline>
<codeline lineno="537"><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"></highlight></codeline>
<codeline lineno="554"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>write_barrier<sp/>=<sp/>false&gt;</highlight></codeline>
<codeline lineno="555"><highlight class="normal">FORCE_INLINE</highlight></codeline>
<codeline lineno="556"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>eth_wait_for_remote_receiver_done_and_get_local_receiver_data(</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>tt_l1_ptr<sp/>uint32_t*<sp/>sender_semaphore_addr_ptr,</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>receiver_semaphore_noc_addr,</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/>uint64_t<sp/>receiver_data_noc_addr,</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>local_eth_l1_curr_src_addr,</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/>uint32_t<sp/>size</highlight></codeline>
<codeline lineno="562"><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>internal_::eth_send_packet(</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>((uint32_t)(&amp;(erisc_info-&gt;channels[0].bytes_sent)))<sp/>&gt;&gt;<sp/>4,</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1);</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/>eth_noc_semaphore_wait(sender_semaphore_addr_ptr,<sp/>1);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="dataflow__api_8h_1ab97e89d297b36a2143d7f57011dd7ec5" kindref="member">noc_async_read</ref>(receiver_data_noc_addr,<sp/>local_eth_l1_curr_src_addr,<sp/>size);</highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="dataflow__api_8h_1af02a9af640679b00da874318535aa397" kindref="member">noc_semaphore_set</ref>(sender_semaphore_addr_ptr,<sp/>0);</highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/>eth_noc_async_read_barrier();</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(write_barrier)<sp/>{</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>eth_noc_async_write_barrier();</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="dataflow__api_8h_1a4eda1737bf554c8bfe4bc603f4d41a43" kindref="member">noc_semaphore_inc</ref>(receiver_semaphore_noc_addr,<sp/>1);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(erisc_info-&gt;channels[0].bytes_sent<sp/>!=<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>internal_::risc_context_switch();</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="579"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="tt_metal/hw/inc/ethernet/dataflow_api.h"/>
  </compounddef>
</doxygen>
