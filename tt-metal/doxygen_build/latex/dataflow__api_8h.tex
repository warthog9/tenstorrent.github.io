\doxysection{tt\+\_\+metal/hw/inc/dataflow\+\_\+api.h File Reference}
\hypertarget{dataflow__api_8h}{}\label{dataflow__api_8h}\index{tt\_metal/hw/inc/dataflow\_api.h@{tt\_metal/hw/inc/dataflow\_api.h}}
{\ttfamily \#include $<$stdint.\+h$>$}\newline
{\ttfamily \#include "{}circular\+\_\+buffer.\+h"{}}\newline
{\ttfamily \#include "{}debug/sanitize\+\_\+noc.\+h"{}}\newline
{\ttfamily \#include "{}debug/status.\+h"{}}\newline
{\ttfamily \#include "{}eth\+\_\+l1\+\_\+address\+\_\+map.\+h"{}}\newline
{\ttfamily \#include "{}hostdevcommon/common\+\_\+runtime\+\_\+address\+\_\+map.\+h"{}}\newline
{\ttfamily \#include "{}hostdevcommon/common\+\_\+values.\+hpp"{}}\newline
{\ttfamily \#include "{}risc\+\_\+attribs.\+h"{}}\newline
{\ttfamily \#include "{}third\+\_\+party/umd/device/tt\+\_\+silicon\+\_\+driver\+\_\+common.\+hpp"{}}\newline
{\ttfamily \#include "{}debug/assert.\+h"{}}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_interleaved_addr_gen}{Interleaved\+Addr\+Gen$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{struct_interleaved_pow2_addr_gen}{Interleaved\+Pow2\+Addr\+Gen$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{struct_interleaved_addr_gen_fast}{Interleaved\+Addr\+Gen\+Fast$<$ DRAM $>$}}
\item 
struct \mbox{\hyperlink{struct_interleaved_pow2_addr_gen_fast}{Interleaved\+Pow2\+Addr\+Gen\+Fast$<$ DRAM $>$}}
\item 
class \mbox{\hyperlink{class_buffer}{Buffer}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{dataflow__api_8h_a56cf50350ff87477df00fb899480ff2d}\label{dataflow__api_8h_a56cf50350ff87477df00fb899480ff2d} 
\#define {\bfseries NOC\+\_\+\+UNICAST\+\_\+\+WRITE\+\_\+\+VC}~1
\item 
\Hypertarget{dataflow__api_8h_a5fb39d71d6c419e9ad7aa0f43e5a91d8}\label{dataflow__api_8h_a5fb39d71d6c419e9ad7aa0f43e5a91d8} 
\#define {\bfseries NOC\+\_\+\+MULTICAST\+\_\+\+WRITE\+\_\+\+VC}~4
\item 
\Hypertarget{dataflow__api_8h_a49104913a904db0ef5c642d10a33c923}\label{dataflow__api_8h_a49104913a904db0ef5c642d10a33c923} 
\#define {\bfseries NOC\+\_\+\+DISPATCH\+\_\+\+MULTICAST\+\_\+\+WRITE\+\_\+\+VC}~5
\item 
\Hypertarget{dataflow__api_8h_a025f94b4ff640f3542c106d954c59e55}\label{dataflow__api_8h_a025f94b4ff640f3542c106d954c59e55} 
\#define {\bfseries COMMON\+\_\+\+RT\+\_\+\+ARGS\+\_\+\+OFFSET}~0
\item 
\#define \mbox{\hyperlink{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe}{get\+\_\+compile\+\_\+time\+\_\+arg\+\_\+val}}(arg\+\_\+idx)~KERNEL\+\_\+\+COMPILE\+\_\+\+TIME\+\_\+\+ARG\+\_\+\#\#arg\+\_\+idx
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{dataflow__api_8h_a49d45df0fdb5ae1977850c809e49c448}\label{dataflow__api_8h_a49d45df0fdb5ae1977850c809e49c448} 
enum class {\bfseries Buffer\+Type} \+: uint8\+\_\+t \{ {\bfseries DRAM} = 0
, {\bfseries L1} = 1
, {\bfseries SYSTEM\+\_\+\+MEMORY} = 2
, {\bfseries L1\+\_\+\+SMALL} = 3
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{dataflow__api_8h_ac4752c4d9a07974ce99aaa671a675fe2}\label{dataflow__api_8h_ac4752c4d9a07974ce99aaa671a675fe2} 
uint32\+\_\+t {\bfseries align} (uint32\+\_\+t addr, uint32\+\_\+t alignment)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f}{get\+\_\+arg\+\_\+val}} (int arg\+\_\+idx)
\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a}{get\+\_\+common\+\_\+arg\+\_\+val}} (int arg\+\_\+idx)
\item 
\mbox{\hyperlink{dataflow__api_8h_aaeb67c582bba445a7c2e7eac520cd84e}{\+\_\+\+\_\+attribute\+\_\+\+\_\+}} ((always\+\_\+inline)) const expr static std
\item 
void \mbox{\hyperlink{dataflow__api_8h_a81357224b88562601b42833eec676ffb}{cb\+\_\+push\+\_\+back}} (const int32\+\_\+t operand, const int32\+\_\+t num\+\_\+pages)
\item 
void \mbox{\hyperlink{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}{cb\+\_\+pop\+\_\+front}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
\Hypertarget{dataflow__api_8h_af4a1a9478a83ad216d826dc5f783d1f8}\label{dataflow__api_8h_af4a1a9478a83ad216d826dc5f783d1f8} 
constexpr std\+::int32\+\_\+t {\bfseries get\+\_\+tile\+\_\+size} (const std\+::int32\+\_\+t operand)
\item 
\Hypertarget{dataflow__api_8h_ae214b6c2f978e745f9c24d397dad906d}\label{dataflow__api_8h_ae214b6c2f978e745f9c24d397dad906d} 
constexpr Data\+Format {\bfseries get\+\_\+dataformat} (const std\+::int32\+\_\+t operand)
\item 
\Hypertarget{dataflow__api_8h_af2384f3c7d9784e3e662093136cbed25}\label{dataflow__api_8h_af2384f3c7d9784e3e662093136cbed25} 
void {\bfseries wait\+\_\+for\+\_\+sync\+\_\+register\+\_\+value} (uint32\+\_\+t addr, int32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed}{cb\+\_\+reserve\+\_\+back}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}{cb\+\_\+wait\+\_\+front}} (int32\+\_\+t operand, int32\+\_\+t num\+\_\+pages)
\item 
\Hypertarget{dataflow__api_8h_ae4374fb8ab97c23045cf3f9dd8e1615f}\label{dataflow__api_8h_ae4374fb8ab97c23045cf3f9dd8e1615f} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+multicast\+\_\+addr} (std\+::uint32\+\_\+t noc\+\_\+x\+\_\+start, std\+::uint32\+\_\+t noc\+\_\+y\+\_\+start, std\+::uint32\+\_\+t noc\+\_\+x\+\_\+end, std\+::uint32\+\_\+t noc\+\_\+y\+\_\+end, std\+::uint32\+\_\+t addr)
\item 
\Hypertarget{dataflow__api_8h_a6080fdaa08b51535164a0b439599c2b2}\label{dataflow__api_8h_a6080fdaa08b51535164a0b439599c2b2} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (std\+::uint32\+\_\+t noc\+\_\+x, std\+::uint32\+\_\+t noc\+\_\+y, std\+::uint32\+\_\+t addr)
\item 
\Hypertarget{dataflow__api_8h_aa850145f50aafa428c0d257cfed4fb8c}\label{dataflow__api_8h_aa850145f50aafa428c0d257cfed4fb8c} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr\+\_\+helper} (std\+::uint32\+\_\+t noc\+\_\+xy, std\+::uint32\+\_\+t addr)
\item 
\Hypertarget{dataflow__api_8h_aba0d056dcf68dc0d8745c6eb6d6b36ef}\label{dataflow__api_8h_aba0d056dcf68dc0d8745c6eb6d6b36ef} 
uint64\+\_\+t {\bfseries get\+\_\+dram\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t bank\+\_\+base\+\_\+address, const uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_aefcec950f39f40599c5c01a66d1055e1}\label{dataflow__api_8h_aefcec950f39f40599c5c01a66d1055e1} 
uint64\+\_\+t {\bfseries get\+\_\+l1\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t bank\+\_\+base\+\_\+address, const uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_a6cea6159b23fc89dcfb5daa668439d1c}\label{dataflow__api_8h_a6cea6159b23fc89dcfb5daa668439d1c} 
uint64\+\_\+t {\bfseries get\+\_\+system\+\_\+memory\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t base\+\_\+addr, const uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_ab2336f9ac51bfd90b0393665f608785f}\label{dataflow__api_8h_ab2336f9ac51bfd90b0393665f608785f} 
std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (std\+::uint32\+\_\+t addr)
\item 
void \mbox{\hyperlink{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5}{noc\+\_\+async\+\_\+read}} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_ad2263fe3188c0629cc6c40c30ad8dc27}\label{dataflow__api_8h_ad2263fe3188c0629cc6c40c30ad8dc27} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_aa5dd39896c00012bcafdbff681f456be}\label{dataflow__api_8h_aa5dd39896c00012bcafdbff681f456be} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_abf12fff178e5ec0115fcd9c503835bfe}\label{dataflow__api_8h_abf12fff178e5ec0115fcd9c503835bfe} 
{\footnotesize template$<$bool inc\+\_\+num\+\_\+issued = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+one\+\_\+packet\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr)
\item 
\Hypertarget{dataflow__api_8h_abc73bc75c5461bec168e308cc4dac463}\label{dataflow__api_8h_abc73bc75c5461bec168e308cc4dac463} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t src\+\_\+noc\+\_\+addr)
\item 
\Hypertarget{dataflow__api_8h_a5f0190364ed02bd2ebd4ad9dcaf66606}\label{dataflow__api_8h_a5f0190364ed02bd2ebd4ad9dcaf66606} 
{\footnotesize template$<$bool inc\+\_\+num\+\_\+issued = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_a4258a390cad1838db7970453230d3f20}\label{dataflow__api_8h_a4258a390cad1838db7970453230d3f20} 
void {\bfseries noc\+\_\+async\+\_\+read\+\_\+inc\+\_\+num\+\_\+issued} (std\+::uint32\+\_\+t num\+\_\+issued\+\_\+reads\+\_\+inc)
\item 
\Hypertarget{dataflow__api_8h_ace2e10391566bc043956841d26c2b96a}\label{dataflow__api_8h_ace2e10391566bc043956841d26c2b96a} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_a243f72eb0de9e7694030ecabbdd55441}\label{dataflow__api_8h_a243f72eb0de9e7694030ecabbdd55441} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+one\+\_\+packet} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
\Hypertarget{dataflow__api_8h_a5e5d48b77f56a10bf3edba5d5907ea25}\label{dataflow__api_8h_a5e5d48b77f56a10bf3edba5d5907ea25} 
{\footnotesize template$<$bool non\+\_\+posted = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet\+\_\+set\+\_\+state} (std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_a99bf42adaae3e6926445b84e7c30e20e}\label{dataflow__api_8h_a99bf42adaae3e6926445b84e7c30e20e} 
{\footnotesize template$<$bool non\+\_\+posted = true$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+one\+\_\+packet\+\_\+with\+\_\+state} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint32\+\_\+t dst\+\_\+noc\+\_\+addr)
\item 
\Hypertarget{dataflow__api_8h_aacf5989f91beb6b0ab26d115ac12fe6f}\label{dataflow__api_8h_aacf5989f91beb6b0ab26d115ac12fe6f} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_addr_gen}{Interleaved\+Addr\+Gen}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_a1ca192ad50dc46eabb2688cf1e0f0575}\label{dataflow__api_8h_a1ca192ad50dc46eabb2688cf1e0f0575} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_pow2_addr_gen}{Interleaved\+Pow2\+Addr\+Gen}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_aee5ebbce5f15ef2a4999f983a7d13fe0}\label{dataflow__api_8h_aee5ebbce5f15ef2a4999f983a7d13fe0} 
{\footnotesize template$<$bool DRAM$>$ }\\std\+::uint64\+\_\+t {\bfseries get\+\_\+noc\+\_\+addr} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_addr_gen_fast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_aa628194296041838dd0512194f78cb4b}\label{dataflow__api_8h_aa628194296041838dd0512194f78cb4b} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+page} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_addr_gen}{Interleaved\+Addr\+Gen}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, uint32\+\_\+t offset=0)
\item 
\Hypertarget{dataflow__api_8h_ab74a8d9d97b2e7d1c15454db2c7d7431}\label{dataflow__api_8h_ab74a8d9d97b2e7d1c15454db2c7d7431} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+read\+\_\+tile} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_addr_gen_fast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t dst\+\_\+local\+\_\+l1\+\_\+addr, uint32\+\_\+t offset=0)
\item 
{\footnotesize template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ }\\void \mbox{\hyperlink{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951}{noc\+\_\+async\+\_\+write}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr, std\+::uint32\+\_\+t size)
\item 
\Hypertarget{dataflow__api_8h_afa1c9f72ce143d24b995167a49eff5e4}\label{dataflow__api_8h_afa1c9f72ce143d24b995167a49eff5e4} 
{\footnotesize template$<$bool DRAM$>$ }\\void {\bfseries noc\+\_\+async\+\_\+write\+\_\+tile} (const uint32\+\_\+t id, const \mbox{\hyperlink{struct_interleaved_addr_gen_fast}{Interleaved\+Addr\+Gen\+Fast}}$<$ DRAM $>$ \&s, std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr)
\item 
\Hypertarget{dataflow__api_8h_ade59434c56510191b5e64e8bb024b4c6}\label{dataflow__api_8h_ade59434c56510191b5e64e8bb024b4c6} 
uint32\+\_\+t {\bfseries get\+\_\+semaphore} (uint32\+\_\+t semaphore\+\_\+id)
\item 
\Hypertarget{dataflow__api_8h_a3abbaf66b17c8ab4eb6c4576ef775e0b}\label{dataflow__api_8h_a3abbaf66b17c8ab4eb6c4576ef775e0b} 
uint32\+\_\+t {\bfseries eth\+\_\+get\+\_\+semaphore} (uint32\+\_\+t semaphore\+\_\+id)
\item 
\Hypertarget{dataflow__api_8h_aff57d6bb75c161882cd3751a3f4a67ba}\label{dataflow__api_8h_aff57d6bb75c161882cd3751a3f4a67ba} 
void {\bfseries noc\+\_\+semaphore\+\_\+set\+\_\+remote} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr)
\item 
{\footnotesize template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ }\\void \mbox{\hyperlink{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2}{noc\+\_\+async\+\_\+write\+\_\+multicast}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709}{noc\+\_\+semaphore\+\_\+set\+\_\+multicast}} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
\Hypertarget{dataflow__api_8h_ab629fc4e0e17a8ed09e5a6b264927b18}\label{dataflow__api_8h_ab629fc4e0e17a8ed09e5a6b264927b18} 
void {\bfseries noc\+\_\+semaphore\+\_\+set\+\_\+multicast\+\_\+loopback\+\_\+src} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
\Hypertarget{dataflow__api_8h_a4ac57ae59ef98d40b2081b80e5636d20}\label{dataflow__api_8h_a4ac57ae59ef98d40b2081b80e5636d20} 
void {\bfseries noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+loopback\+\_\+src} (std\+::uint32\+\_\+t src\+\_\+local\+\_\+l1\+\_\+addr, std\+::uint64\+\_\+t dst\+\_\+noc\+\_\+addr\+\_\+multicast, std\+::uint32\+\_\+t size, std\+::uint32\+\_\+t num\+\_\+dests, bool linked=false, bool multicast\+\_\+path\+\_\+reserve=true)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950}{noc\+\_\+async\+\_\+read\+\_\+barrier}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680}{noc\+\_\+async\+\_\+write\+\_\+barrier}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1}{noc\+\_\+async\+\_\+writes\+\_\+flushed}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a22e07009373e4c4c04a0af18ca73cfd7}{noc\+\_\+async\+\_\+atomic\+\_\+barrier}} ()
\item 
void \mbox{\hyperlink{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a}{noc\+\_\+semaphore\+\_\+wait}} (volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a84a965a61b65152c42835f35dca007af}{noc\+\_\+semaphore\+\_\+wait\+\_\+min}} (volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_af02a9af640679b00da874318535aa397}{noc\+\_\+semaphore\+\_\+set}} (volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}sem\+\_\+addr, uint32\+\_\+t val)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1}{noc\+\_\+inline\+\_\+dw\+\_\+write}} (uint64\+\_\+t addr, uint32\+\_\+t val, uint8\+\_\+t be=0xF)
\item 
void \mbox{\hyperlink{dataflow__api_8h_a4eda1737bf554c8bfe4bc603f4d41a43}{noc\+\_\+semaphore\+\_\+inc}} (uint64\+\_\+t addr, uint32\+\_\+t incr)
\item 
\Hypertarget{dataflow__api_8h_a9e9618b5b64ed1ae0d0a747ac0f10745}\label{dataflow__api_8h_a9e9618b5b64ed1ae0d0a747ac0f10745} 
void {\bfseries RISC\+\_\+\+POST\+\_\+\+HEARTBEAT} (uint32\+\_\+t \&heartbeat)
\item 
\Hypertarget{dataflow__api_8h_a29bd290aaee1b41529717b029dc14952}\label{dataflow__api_8h_a29bd290aaee1b41529717b029dc14952} 
uint32\+\_\+t {\bfseries min} (uint32\+\_\+t a, uint32\+\_\+t b)
\item 
\Hypertarget{dataflow__api_8h_a901d9922d4a71afe3e51189d4f414b04}\label{dataflow__api_8h_a901d9922d4a71afe3e51189d4f414b04} 
{\footnotesize template$<$bool READ$>$ }\\void {\bfseries noc\+\_\+async\+\_\+sharded\+\_\+read\+\_\+write\+\_\+helper} (const uint32\+\_\+t num\+\_\+cores, const uint32\+\_\+t page\+\_\+size, const uint32\+\_\+t bank\+\_\+base\+\_\+address, volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}base\+\_\+command\+\_\+addr, const uint32\+\_\+t addr, const uint32\+\_\+t num\+\_\+pages, const uint32\+\_\+t page\+\_\+id)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{dataflow__api_8h_a58bc3a01e945dbd421fce21906e94441}\label{dataflow__api_8h_a58bc3a01e945dbd421fce21906e94441} 
uint8\+\_\+t {\bfseries noc\+\_\+index}
\end{DoxyCompactItemize}


\doxysubsection{Macro Definition Documentation}
\Hypertarget{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe}\index{dataflow\_api.h@{dataflow\_api.h}!get\_compile\_time\_arg\_val@{get\_compile\_time\_arg\_val}}
\index{get\_compile\_time\_arg\_val@{get\_compile\_time\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_compile\_time\_arg\_val}{get\_compile\_time\_arg\_val}}
{\footnotesize\ttfamily \label{dataflow__api_8h_ab97f9dbfbb4150cb324f21520b8e6cfe} 
\#define get\+\_\+compile\+\_\+time\+\_\+arg\+\_\+val(\begin{DoxyParamCaption}\item[{}]{arg\+\_\+idx}{}\end{DoxyParamCaption})~KERNEL\+\_\+\+COMPILE\+\_\+\+TIME\+\_\+\+ARG\+\_\+\#\#arg\+\_\+idx}

Returns the value of a constexpr argument from kernel\+\_\+compile\+\_\+time\+\_\+args array provided during kernel creation using Create\+Kernel calls.

Return value\+: constexpr uint32\+\_\+t

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &The index of the argument   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}


\doxysubsection{Function Documentation}
\Hypertarget{dataflow__api_8h_aaeb67c582bba445a7c2e7eac520cd84e}\index{dataflow\_api.h@{dataflow\_api.h}!\_\_attribute\_\_@{\_\_attribute\_\_}}
\index{\_\_attribute\_\_@{\_\_attribute\_\_}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{\_\_attribute\_\_()}{\_\_attribute\_\_()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_aaeb67c582bba445a7c2e7eac520cd84e} 
\+\_\+\+\_\+attribute\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{(always\+\_\+inline)}]{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Returns a pointer to the beginning of a memory block previously reserved by cb\+\_\+reserve\+\_\+back. Note that this call is only valid between calls to cb\+\_\+reserve\+\_\+back and cb\+\_\+push\+\_\+back. The amount of valid memory is equal to the number of tiles requested in a prior cb\+\_\+reserve\+\_\+back call.

CB total size must be an even multiple of this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
operand   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}


Returns a pointer to the beginning of a memory block previously received by cb\+\_\+wait\+\_\+front. Note that this call is only valid between calls to cb\+\_\+wait\+\_\+front and cb\+\_\+pop\+\_\+front. The amount of valid memory is equal to the number of tiles requested in a prior cb\+\_\+wait\+\_\+front call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
operand   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}\index{dataflow\_api.h@{dataflow\_api.h}!cb\_pop\_front@{cb\_pop\_front}}
\index{cb\_pop\_front@{cb\_pop\_front}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_pop\_front()}{cb\_pop\_front()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0} 
void cb\+\_\+pop\+\_\+front (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand}{, }\item[{int32\+\_\+t}]{num\+\_\+pages}{}\end{DoxyParamCaption})}

Pops a specified number of tiles from the front of the specified CB. This also frees this number of tiles in the circular buffer. This call is used by the consumer to free up the space in the CB.

We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.

Note that the act of reading of the tile data from the CB does not free up the space in the CB. Waiting on available tiles and popping them is separated in order to allow the consumer to\+: 1) read the tile data from the CB via multiple reads of sub-\/tiles 2) access the tiles (or their sub-\/tiles) that are visible to the consumer by random access of the valid section of the CB

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to be popped   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a81357224b88562601b42833eec676ffb}\index{dataflow\_api.h@{dataflow\_api.h}!cb\_push\_back@{cb\_push\_back}}
\index{cb\_push\_back@{cb\_push\_back}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_push\_back()}{cb\_push\_back()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a81357224b88562601b42833eec676ffb} 
void cb\+\_\+push\+\_\+back (\begin{DoxyParamCaption}\item[{const int32\+\_\+t}]{operand}{, }\item[{const int32\+\_\+t}]{num\+\_\+pages}{}\end{DoxyParamCaption})}

Pushes a given number of tiles in the back of the specified CB’s queue. Decreases the available space in the circular buffer by this number of tiles. This call is used by the producer to make the tiles visible to the consumer of the CB.

We use the convention that the producer pushes tiles into the “back” of the CB queue and the consumer consumes tiles from the “front” of the CB queue.

Note that the act of writing the tile data into the CB does not make the tiles visible to the consumer. Writing of the tiles and pushing is separated to allow the producer to\+: 1) write the tile data to the CB via multiple writes of sub-\/tiles 2) modify tiles (or sub-\/tiles) by random access of the valid section of the CB

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to be pushed   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed}\index{dataflow\_api.h@{dataflow\_api.h}!cb\_reserve\_back@{cb\_reserve\_back}}
\index{cb\_reserve\_back@{cb\_reserve\_back}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_reserve\_back()}{cb\_reserve\_back()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a29521dee07b0070674a988f66c01ffed} 
void cb\+\_\+reserve\+\_\+back (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand}{, }\item[{int32\+\_\+t}]{num\+\_\+pages}{}\end{DoxyParamCaption})}

A blocking call that waits for the specified number of tiles to be free in the specified circular buffer. This call is used by the producer to wait for the consumer to consume (ie. free up) the specified number of tiles.

CB total size must be an even multiple of the argument passed to this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of free tiles to wait for   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}\index{dataflow\_api.h@{dataflow\_api.h}!cb\_wait\_front@{cb\_wait\_front}}
\index{cb\_wait\_front@{cb\_wait\_front}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{cb\_wait\_front()}{cb\_wait\_front()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a} 
void cb\+\_\+wait\+\_\+front (\begin{DoxyParamCaption}\item[{int32\+\_\+t}]{operand}{, }\item[{int32\+\_\+t}]{num\+\_\+pages}{}\end{DoxyParamCaption})}

A blocking call that waits for the specified number of tiles to be available in the specified circular buffer (CB). This call is used by the consumer of the CB to wait for the producer to fill the CB with at least the specfied number of tiles. Important note\+: in case multiple calls of cb\+\_\+wait\+\_\+front(n) are issued without a paired \doxylink{dataflow__api_8h_aa3daf8e5e7299140cf2607be1a8656b0}{cb\+\_\+pop\+\_\+front()} call, n is expected to be incremented by the user to be equal to a cumulative total of tiles. Example\+: 4 calls of cb\+\_\+wait\+\_\+front(8) followed by a cb\+\_\+pop\+\_\+front(32) would produce incorrect behavior. Instead 4 calls of \doxylink{dataflow__api_8h_af6d8057bd05a650c3501c5208f7d9f8a}{cb\+\_\+wait\+\_\+front()} waiting on 8, 16, 24, 32 tiles should be issued.

Important note\+: number of tiles used in all cb\+\_\+\texorpdfstring{$\ast$}{*} calls must evenly divide the cb size and must be the same number in all cb\+\_\+wait\+\_\+front calls in the same kernel. Example 1\+: cb\+\_\+wait\+\_\+front(32), cb\+\_\+wait\+\_\+front(40), cb\+\_\+pop\+\_\+front(32+8) tiles on a CB of size 64 would produce incorrect behavior. Example 2\+: cb\+\_\+wait\+\_\+front(3) on a cb of size 32 would also produce incorrect behavior. These limitations are due to performance optimizations in the CB implementation.

Important note\+: CB total size must be an even multiple of the argument passed to this call.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
cb\+\_\+id   &The index of the cirular buffer (CB)   &uint32\+\_\+t   &0 to 31   &True    \\\cline{1-5}
num\+\_\+tiles   &The number of tiles to wait for   &uint32\+\_\+t   &It must be less or equal than the size of the CB (the total number of tiles that fit into the CB)   &\\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f}\index{dataflow\_api.h@{dataflow\_api.h}!get\_arg\_val@{get\_arg\_val}}
\index{get\_arg\_val@{get\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_arg\_val()}{get\_arg\_val()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a6a5074e8cd2732fcecab57fced3ebd1f} 
template$<$typename T $>$ \\
T get\+\_\+arg\+\_\+val (\begin{DoxyParamCaption}\item[{int}]{arg\+\_\+idx}{}\end{DoxyParamCaption})}

Returns the value at a given runtime argument index for unique (per-\/core) runtime arguments set via Set\+Runtime\+Args() API.

Return value\+: The value associated with the unique runtime argument index

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &Unique Runtime argument index   &uint32\+\_\+t   &0 to 255   &True    \\\cline{1-5}
T (template argument)   &Data type of the returned argument   &Any 4-\/byte sized type   &N/A   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a}\index{dataflow\_api.h@{dataflow\_api.h}!get\_common\_arg\_val@{get\_common\_arg\_val}}
\index{get\_common\_arg\_val@{get\_common\_arg\_val}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{get\_common\_arg\_val()}{get\_common\_arg\_val()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_abba486e3732fb5ea715651f92234e60a} 
template$<$typename T $>$ \\
T get\+\_\+common\+\_\+arg\+\_\+val (\begin{DoxyParamCaption}\item[{int}]{arg\+\_\+idx}{}\end{DoxyParamCaption})}

Returns the value at a given runtime argument index for common (all cores) runtime arguments set via Set\+Common\+Runtime\+Args() API.

Return value\+: The value associated with the common runtime argument index

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
arg\+\_\+idx   &Common Runtime argument index   &uint32\+\_\+t   &0 to 255   &True    \\\cline{1-5}
T (template argument)   &Data type of the returned argument   &Any 4-\/byte sized type   &N/A   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a22e07009373e4c4c04a0af18ca73cfd7}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_atomic\_barrier@{noc\_async\_atomic\_barrier}}
\index{noc\_async\_atomic\_barrier@{noc\_async\_atomic\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_atomic\_barrier()}{noc\_async\_atomic\_barrier()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a22e07009373e4c4c04a0af18ca73cfd7} 
void noc\+\_\+async\+\_\+atomic\+\_\+barrier (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+write} queue will be empty for the current Tensix core.

Return value\+: None \Hypertarget{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_read@{noc\_async\_read}}
\index{noc\_async\_read@{noc\_async\_read}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_read()}{noc\_async\_read()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_ab97e89d297b36a2143d7f57011dd7ec5} 
void noc\+\_\+async\+\_\+read (\begin{DoxyParamCaption}\item[{std\+::uint64\+\_\+t}]{src\+\_\+noc\+\_\+addr}{, }\item[{std\+::uint32\+\_\+t}]{dst\+\_\+local\+\_\+l1\+\_\+addr}{, }\item[{std\+::uint32\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous read from a specified source node located at NOC coordinates (x,y) at a local address (encoded as a uint64\+\_\+t using {\itshape get\+\_\+noc\+\_\+addr} function). The destination is in L1 memory on the Tensix core executing this function call. Also, see {\itshape noc\+\_\+async\+\_\+read\+\_\+barrier}.

The source node can be either a DRAM bank, a Tensix core or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Data type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Data type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ required    }\\\cline{1-5}
\endhead
src\+\_\+noc\+\_\+addr   &Encoding of the source DRAM location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(ref to explain valid coords)   &Yes    \\\cline{1-5}
dst\+\_\+local\+\_\+l1\+\_\+addr   &Address in local L1 memory   &uint32\+\_\+t   &0..1MB   &Yes    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &Yes   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_read\_barrier@{noc\_async\_read\_barrier}}
\index{noc\_async\_read\_barrier@{noc\_async\_read\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_read\_barrier()}{noc\_async\_read\_barrier()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a8da61f7d36de3d865b04acf3656c7950} 
void noc\+\_\+async\+\_\+read\+\_\+barrier (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+read} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+read} queue will be empty for the current Tensix core.

Return value\+: None \Hypertarget{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write@{noc\_async\_write}}
\index{noc\_async\_write@{noc\_async\_write}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write()}{noc\_async\_write()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_ae5353d488f5a68e6eb89fae5ea1be951} 
template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ \\
void noc\+\_\+async\+\_\+write (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr}{, }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr}{, }\item[{std\+::uint32\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call. The destination is specified using a uint64\+\_\+t encoding referencing an on-\/chip node located at NOC coordinates (x,y) and a local address created using get\+\_\+noc\+\_\+addr function. Also, see {\itshape noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination node can be either a DRAM bank, Tensix core+\+L1 memory address or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr   &Encoding of the destination DRAM location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write\_barrier@{noc\_async\_write\_barrier}}
\index{noc\_async\_write\_barrier@{noc\_async\_write\_barrier}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write\_barrier()}{noc\_async\_write\_barrier()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a8a1af3e9115ddcd9d2e4b0c8b4a4b680} 
void noc\+\_\+async\+\_\+write\+\_\+barrier (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

This blocking call waits for all the outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to complete. After returning from this call the {\itshape noc\+\_\+async\+\_\+write} queue will be empty for the current Tensix core.

Return value\+: None \Hypertarget{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_write\_multicast@{noc\_async\_write\_multicast}}
\index{noc\_async\_write\_multicast@{noc\_async\_write\_multicast}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_write\_multicast()}{noc\_async\_write\_multicast()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_aebb548dd7fb5654248c32b147531c8d2} 
template$<$uint32\+\_\+t max\+\_\+page\+\_\+size = NOC\+\_\+\+MAX\+\_\+\+BURST\+\_\+\+SIZE + 1$>$ \\
void noc\+\_\+async\+\_\+write\+\_\+multicast (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr}{, }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr\+\_\+multicast}{, }\item[{std\+::uint32\+\_\+t}]{size}{, }\item[{std\+::uint32\+\_\+t}]{num\+\_\+dests}{, }\item[{bool}]{linked}{ = {\ttfamily false}, }\item[{bool}]{multicast\+\_\+path\+\_\+reserve}{ = {\ttfamily true}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64\+\_\+t encoding referencing an on-\/chip grid of nodes located at NOC coordinate range (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end) and a local address created using {\itshape get\+\_\+noc\+\_\+multicast\+\_\+addr} function. Also, {\itshape see noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination nodes can only be a set of Tensix cores + L1 memory address. The destination nodes must form a rectangular grid. The destination L1 memory address must be the same on all destination nodes.

With this API, the multicast sender cannot be part of the multicast destinations. If the multicast sender has to be in the multicast destinations (i.\+e. must perform a local L1 write), the other API variant {\itshape noc\+\_\+async\+\_\+write\+\_\+multicast\+\_\+loopback\+\_\+src} can be used.

Note\+: there is no restriction on the number of destinations, i.\+e. the multicast destinations can span the full chip. However, as mentioned previosuly, the multicast source cannot be part of the destinations. So, the maximum number of destinations is 119.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr\+\_\+multicast   &Encoding of the destinations nodes (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
size   &Size of data transfer in bytes   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
num\+\_\+dests   &Number of destinations that the multicast source is targetting   &uint32\+\_\+t   &0..119   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_async\_writes\_flushed@{noc\_async\_writes\_flushed}}
\index{noc\_async\_writes\_flushed@{noc\_async\_writes\_flushed}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_async\_writes\_flushed()}{noc\_async\_writes\_flushed()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a82c38db0fda2eaafccd0aac9635f0dc1} 
void noc\+\_\+async\+\_\+writes\+\_\+flushed (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

This blocking call waits for all outstanding enqueued {\itshape noc\+\_\+async\+\_\+write} calls issued on the current Tensix core to depart, but will not wait for them to complete \Hypertarget{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_inline\_dw\_write@{noc\_inline\_dw\_write}}
\index{noc\_inline\_dw\_write@{noc\_inline\_dw\_write}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_inline\_dw\_write()}{noc\_inline\_dw\_write()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a1f11981622b01c9e42d44a939ec30be1} 
void noc\+\_\+inline\+\_\+dw\+\_\+write (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{addr}{, }\item[{uint32\+\_\+t}]{val}{, }\item[{uint8\+\_\+t}]{be}{ = {\ttfamily 0xF}}\end{DoxyParamCaption})}

Initiates an asynchronous write of a 32-\/bit value to a NOC destination. Typically used for writing registers, but can be used for memory locations as well. The destination is specified as a 64-\/bit NOC address (see {\itshape noc\+\_\+async\+\_\+write}). The advantage over using {\itshape noc\+\_\+async\+\_\+write} is that we don\textquotesingle{}t a Tensix L1 memory source location; the write value is written directly into a register. Unlike using {\itshape noc\+\_\+async\+\_\+write}, there are also no address alignment concerns. Also, see {\itshape noc\+\_\+async\+\_\+write\+\_\+barrier}.

The destination node can be either a DRAM bank, Tensix core+\+L1 memory address or a PCIe controller.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
addr   &Encoding of the destination location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
val   &The value to be written   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True    \\\cline{1-5}
be   &Byte-\/enable   &uint8\+\_\+t   &0x1-\/0xF   &False   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a4eda1737bf554c8bfe4bc603f4d41a43}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_inc@{noc\_semaphore\_inc}}
\index{noc\_semaphore\_inc@{noc\_semaphore\_inc}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_inc()}{noc\_semaphore\_inc()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a4eda1737bf554c8bfe4bc603f4d41a43} 
void noc\+\_\+semaphore\+\_\+inc (\begin{DoxyParamCaption}\item[{uint64\+\_\+t}]{addr}{, }\item[{uint32\+\_\+t}]{incr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

The Tensix core executing this function call initiates an atomic increment (with 32-\/bit wrap) of a remote Tensix core L1 memory address. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
addr   &Encoding of the destination location (x,y)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
incr   &The value to increment by   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_af02a9af640679b00da874318535aa397}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_set@{noc\_semaphore\_set}}
\index{noc\_semaphore\_set@{noc\_semaphore\_set}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_set()}{noc\_semaphore\_set()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_af02a9af640679b00da874318535aa397} 
void noc\+\_\+semaphore\+\_\+set (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}}]{sem\+\_\+addr}{, }\item[{uint32\+\_\+t}]{val}{}\end{DoxyParamCaption})}

Sets the value of a local L1 memory address on the Tensix core executing this function to a specific value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+wait}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &Value to set the semaphore to   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_set\_multicast@{noc\_semaphore\_set\_multicast}}
\index{noc\_semaphore\_set\_multicast@{noc\_semaphore\_set\_multicast}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_set\_multicast()}{noc\_semaphore\_set\_multicast()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_af1debd77eb9592540a899290fb2a1709} 
void noc\+\_\+semaphore\+\_\+set\+\_\+multicast (\begin{DoxyParamCaption}\item[{std\+::uint32\+\_\+t}]{src\+\_\+local\+\_\+l1\+\_\+addr}{, }\item[{std\+::uint64\+\_\+t}]{dst\+\_\+noc\+\_\+addr\+\_\+multicast}{, }\item[{std\+::uint32\+\_\+t}]{num\+\_\+dests}{, }\item[{bool}]{linked}{ = {\ttfamily false}, }\item[{bool}]{multicast\+\_\+path\+\_\+reserve}{ = {\ttfamily true}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initiates an asynchronous write from a source address in L1 memory on the Tensix core executing this function call to a rectangular destination grid. The destinations are specified using a uint64\+\_\+t encoding referencing an on-\/chip grid of nodes located at NOC coordinate range (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end) and a local address created using {\itshape get\+\_\+noc\+\_\+multicast\+\_\+addr} function. The size of data that is sent is 4 Bytes. This is usually used to set a semaphore value at the destination nodes, as a way of a synchronization mechanism. The same as {\itshape noc\+\_\+async\+\_\+write\+\_\+multicast} with preset size of 4 Bytes.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
src\+\_\+local\+\_\+l1\+\_\+addr   &Source address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
dst\+\_\+noc\+\_\+addr\+\_\+multicast   &Encoding of the destinations nodes (x\+\_\+start,y\+\_\+start,x\+\_\+end,y\+\_\+end)+address   &uint64\+\_\+t   &DOX-\/\+TODO(insert a reference to what constitutes valid coords)   &True    \\\cline{1-5}
num\+\_\+dests   &Number of destinations that the multicast source is targetting   &uint32\+\_\+t   &0..119   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_wait@{noc\_semaphore\_wait}}
\index{noc\_semaphore\_wait@{noc\_semaphore\_wait}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_wait()}{noc\_semaphore\_wait()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a4f714cc4a08a2eaac5e3f7fae9d1383a} 
void noc\+\_\+semaphore\+\_\+wait (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}}]{sem\+\_\+addr}{, }\item[{uint32\+\_\+t}]{val}{}\end{DoxyParamCaption})}

A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal to a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+set}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &The target value of the semaphore   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
\Hypertarget{dataflow__api_8h_a84a965a61b65152c42835f35dca007af}\index{dataflow\_api.h@{dataflow\_api.h}!noc\_semaphore\_wait\_min@{noc\_semaphore\_wait\_min}}
\index{noc\_semaphore\_wait\_min@{noc\_semaphore\_wait\_min}!dataflow\_api.h@{dataflow\_api.h}}
\doxysubsubsection{\texorpdfstring{noc\_semaphore\_wait\_min()}{noc\_semaphore\_wait\_min()}}
{\footnotesize\ttfamily \label{dataflow__api_8h_a84a965a61b65152c42835f35dca007af} 
void noc\+\_\+semaphore\+\_\+wait\+\_\+min (\begin{DoxyParamCaption}\item[{volatile uint32\+\_\+t \texorpdfstring{$\ast$}{*}}]{sem\+\_\+addr}{, }\item[{uint32\+\_\+t}]{val}{}\end{DoxyParamCaption})}

A blocking call that waits until the value of a local L1 memory address on the Tensix core executing this function becomes equal or greater than a target value. This L1 memory address is used as a semaphore of size 4 Bytes, as a synchronization mechanism. Also, see {\itshape noc\+\_\+semaphore\+\_\+set}.

Return value\+: None

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{5}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Argument   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Type   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Valid Range   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Required    }\\\cline{1-5}
\endhead
sem\+\_\+addr   &Semaphore address in local L1 memory   &uint32\+\_\+t   &0..1MB   &True    \\\cline{1-5}
val   &The target value of the semaphore   &uint32\+\_\+t   &Any uint32\+\_\+t value   &True   \\\cline{1-5}
\end{longtabu}
